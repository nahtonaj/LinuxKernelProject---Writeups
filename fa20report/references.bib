
@article{beheraEnergyefficientTimetriggeredScheduling2020,
  title = {An Energy-Efficient Time-Triggered Scheduling Algorithm for Mixed-Criticality Systems},
  author = {Behera, Lalatendu and Bhaduri, Purandar},
  year = {2020},
  month = jun,
  volume = {24},
  pages = {79--109},
  issn = {1572-8080},
  doi = {10.1007/s10617-019-09232-3},
  abstract = {Real-time safety-critical systems are getting more complicated due to the introduction of mixed-criticality systems. The increasing use of mixed-criticality systems has motivated the real-time systems research community to investigate various non-functional aspects of these systems. Energy consumption minimization is one such aspect which is just beginning to be explored. In this paper, we propose a time-triggered dynamic voltage and frequency scaling (DVFS) algorithm for uniprocessor mixed-criticality systems. We show that our algorithm outperforms the predominant existing algorithm which uses DVFS for mixed-criticality systems with respect to minimization of energy consumption. In addition, ours is the first energy-efficient time-triggered algorithm for mixed-criticality systems. We prove an optimality result for the proposed algorithm with respect to energy consumption. Then we extend our algorithm for tasks with dependency constraints.},
  journal = {Design Automation for Embedded Systems},
  language = {en},
  number = {2}
}

@misc{BKK19TR03LinuxKernel,
  title = {{{BKK19}}-{{TR03}} - {{The Linux Kernel Scheduler}} - {{Overview}} - {{YouTube}}},
  howpublished = {https://www.youtube.com/watch?v=oOiaRHC9ZDg}
}

@article{BrainFuckScheduler2020,
  title = {Brain {{Fuck Scheduler}}},
  year = {2020},
  month = oct,
  abstract = {The Brain Fuck Scheduler (BFS) is a process scheduler designed for the Linux kernel in August 2009 as an alternative to the Completely Fair Scheduler (CFS) and the O(1) scheduler. BFS was created by veteran kernel programmer Con Kolivas.The objective of BFS, compared to other schedulers, is to provide a scheduler with a simpler algorithm, that does not require adjustment of heuristics or tuning parameters to tailor performance to a specific type of computational workload. Kolivas asserted that these tunable parameters were difficult for the average user to understand, especially in terms of interactions of multiple parameters with each other, and claimed that the use of such tuning parameters could often result in improved performance in a specific targeted type of computation, at the cost of worse performance in the general case. BFS has been reported to improve responsiveness on Linux desktop computers with fewer than 16 cores.Shortly following its introduction, the new scheduler made headlines within the Linux community, appearing on Slashdot, with reviews in Linux Magazine and Linux Pro Magazine. Although there have been varied reviews of improved performance and responsiveness, Con Kolivas did not intend for BFS to be integrated into the mainline kernel.},
  annotation = {Page Version ID: 982869148},
  copyright = {Creative Commons Attribution-ShareAlike License},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\DXPX43QK\\index.html},
  journal = {Wikipedia},
  language = {en}
}

@misc{brennanTutorialWriteSystem,
  title = {Tutorial - {{Write}} a {{System Call}} - {{Stephen Brennan}}},
  author = {Brennan, Stephen},
  abstract = {Stephen Brennan's personal website and blog.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\TAQCXXZ7\\kernel-dev-ep3.html},
  howpublished = {https://brennan.io/2016/11/14/kernel-dev-ep3/},
  journal = {Stephen Brennan's Blog}
}

@misc{CgroupsLinuxManual,
  title = {Cgroups(7) - {{Linux}} Manual Page},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\8U49WV7W\\cgroups.7.html},
  howpublished = {https://man7.org/linux/man-pages/man7/cgroups.7.html}
}

@misc{ConfiguringKernelRaspberry,
  title = {Configuring the Kernel - {{Raspberry Pi Documentation}}},
  howpublished = {https://www.raspberrypi.org/documentation/linux/kernel/configuring.md}
}

@misc{ControlGroupsLinux,
  title = {Control {{Groups}} \textemdash{} {{The Linux Kernel}} Documentation},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\3XU98CKW\\cgroups.html},
  howpublished = {https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v1/cgroups.html}
}

@misc{CPUFrequencyScaling,
  title = {{{CPU}} Frequency Scaling - {{ArchWiki}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\XI9RXE4E\\CPU_frequency_scaling.html},
  howpublished = {https://wiki.archlinux.org/index.php/CPU\_frequency\_scaling}
}

@misc{CpuNiceHas,
  title = {Cpu - Nice Has No Effect in {{Linux}} Unless the Same Shell Is Used},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\7N5SPT2K\\nice-has-no-effect-in-linux-unless-the-same-shell-is-used.html},
  howpublished = {https://superuser.com/questions/805599/nice-has-no-effect-in-linux-unless-the-same-shell-is-used},
  journal = {Super User}
}

@misc{CpuschedmultiPdf,
  title = {Cpu-Sched-Multi.Pdf},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\FQW9X6E3\\cpu-sched-multi.pdf},
  howpublished = {http://pages.cs.wisc.edu/\textasciitilde remzi/OSTEP/cpu-sched-multi.pdf}
}

@misc{DifferenceMultilevelQueue2020,
  title = {Difference between {{Multilevel Queue}} ({{MLQ}}) and {{Multi Level Feedback Queue}} ({{MLFQ}}) {{CPU}} Scheduling Algorithms},
  year = {2020},
  month = jul,
  abstract = {A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.},
  chapter = {Operating Systems},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\PUQTV2HN\\difference-between-multilevel-queue-mlq-and-multi-level-feedback-queue-mlfq-cpu-scheduling-algo.html},
  howpublished = {https://www.geeksforgeeks.org/difference-between-multilevel-queue-mlq-and-multi-level-feedback-queue-mlfq-cpu-scheduling-algorithms/},
  journal = {GeeksforGeeks},
  language = {en-US},
  type = {{{GeeksforGeeks}}}
}

@misc{DocumentationSchedulerKernel,
  title = {Documentation/Scheduler - Kernel/Msm - {{Git}} at {{Google}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\JGWIZWW9\\scheduler.html},
  howpublished = {https://android.googlesource.com/kernel/msm/+/android-msm-bullhead-3.10-marshmallow-dr/Documentation/scheduler}
}

@misc{DocumentationSchedulerScheddesignCFS,
  title = {Documentation/Scheduler/Sched-Design-{{CFS}}.Txt - Kernel/Msm - {{Git}} at {{Google}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\EUJI8Z4V\\sched-design-CFS.html},
  howpublished = {https://android.googlesource.com/kernel/msm/+/android-msm-bullhead-3.10-marshmallow-dr/Documentation/scheduler/sched-design-CFS.txt}
}

@misc{DocumentationSchedulerSchednicedesign,
  title = {Documentation/Scheduler/Sched-Nice-Design.Txt - Kernel/Msm - {{Git}} at {{Google}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\JHHKLLVI\\sched-nice-design.html},
  howpublished = {https://android.googlesource.com/kernel/msm/+/android-msm-bullhead-3.10-marshmallow-dr/Documentation/scheduler/sched-nice-design.txt}
}

@misc{heoControlGroupV22015,
  title = {Control {{Group}} V2},
  author = {Heo, Tejun},
  year = {2015},
  month = oct,
  file = {C\:\\Users\\jonat\\Zotero\\storage\\XGDSNZXT\\cgroup-v2.html},
  howpublished = {https://www.kernel.org/doc/Documentation/cgroup-v2.txt}
}

@misc{InfluenceSchedulingPriority2006,
  title = {Influence Scheduling Priority with Nice and Renice},
  year = {2006},
  month = nov,
  abstract = {Author: Evi Nemeth, Garth Snyder, and Trent R. Hein The ``niceness'' of a process is a numeric hint to the kernel about how the process should be treated in relation to other processes contending for the CPU. The strange name is derived from the fact that it determines how nice you are going to be \ldots},
  chapter = {News},
  journal = {Linux.com},
  language = {en-US}
}

@article{ishkovCompleteGuideLinux,
  title = {A Complete Guide to {{Linux}} Process Scheduling},
  author = {Ishkov, Nikita},
  pages = {62},
  abstract = {The subject of this thesis is process scheduling in wide purpose operating systems. For many years kernel hackers all over the world tried to accomplish the seemingly infeasible task of achieving good interaction on desktop systems and low latencies on heavily loaded server machines. Some progress has been made in this area since the rise of free software, but, in opinion of many, it is still far from perfect. Lots of beginner operating system enthusiasts find the existing solutions too complex to understand and, in light of almost complete lack of documentation along with common hostility of active kernel developers towards rookies, impossible to get hands on. Anyone who has the courage to wade into the dragon infested layer that is the scheduler, should be aware of the ideas behind current implementations before making any contributions. That is what this thesis is about \textendash{} showing how things work under the hood and how they developed to be like this. Every decision behind each concept in a kernel of an OS has its history and meaning. Here I will guide you through process scheduling mechanisms in currently stable Linux kernel as an object lesson on the matter. The work starts with an overview of the essentials of process abstraction in Linux, and continues with detailed code-level description of scheduling techniques involved in past and present kernels.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\JQJRH4YF\\Ishkov - A complete guide to Linux process scheduling.pdf},
  language = {en}
}

@misc{KernelBuildingRaspberry,
  title = {Kernel Building - {{Raspberry Pi Documentation}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\L3W2LPGQ\\building.html},
  howpublished = {https://www.raspberrypi.org/documentation/linux/kernel/building.md}
}

@misc{KernelBuildYourOwnKernelUbuntu,
  title = {Kernel/{{BuildYourOwnKernel}} - {{Ubuntu Wiki}}},
  howpublished = {https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel}
}

@misc{KernelOrg,
  title = {Kernel.Org},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\HGII4WX4\\kconfig.html},
  howpublished = {https://www.kernel.org/doc/Documentation/kbuild/kconfig.txt}
}

@misc{LIBSVMLibrarySupport,
  title = {{{LIBSVM}} -- {{A Library}} for {{Support Vector Machines}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\UJ3432KE\\libsvm.html},
  howpublished = {https://www.csie.ntu.edu.tw/\textasciitilde cjlin/libsvm/}
}

@misc{LinuxKernelArchiveRFC,
  title = {Linux-{{Kernel Archive}}: {{RFC}}: Documentation of the Autogroup Feature [V2]},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\6ZJW82TJ\\00766.html},
  howpublished = {http://lkml.iu.edu/hypermail/linux/kernel/1611.3/00766.html}
}

@misc{LinuxKernelDocumentation,
  title = {The {{Linux Kernel}} Documentation \textemdash{} {{The Linux Kernel}} Documentation},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\7FL43I59\\latest.html},
  howpublished = {https://www.kernel.org/doc/html/latest/}
}

@misc{LinuxSchedulerDecade,
  title = {The {{Linux Scheduler}}: A {{Decade}} of {{Wasted Cores}} | the Morning Paper},
  shorttitle = {The {{Linux Scheduler}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\KJ5GWLZS\\the-linux-scheduler-a-decade-of-wasted-cores.html},
  language = {en-GB}
}

@misc{misitiJosephmisitiAwesomemachinelearning2020,
  title = {Josephmisiti/Awesome-Machine-Learning},
  author = {Misiti, Joseph},
  year = {2020},
  month = oct,
  abstract = {A curated list of awesome Machine Learning frameworks, libraries and software.},
  copyright = {View license         ,                 View license}
}

@article{MultilevelFeedbackQueue2020,
  title = {Multilevel Feedback Queue},
  year = {2020},
  month = sep,
  abstract = {In computer science, a multilevel feedback queue is a scheduling algorithm. Solaris 2.6 Time-Sharing (TS) scheduler implements this algorithm. The MacOS and Microsoft Windows schedulers can both be regarded as examples of the broader class of multilevel feedback queue schedulers. This scheduling algorithm is intended to meet the following design requirements for multimode systems: Give preference to short jobs. Give preference to I/O bound processes. Separate processes into categories based on their need for the processor.The Multi-level Feedback Queue scheduler was first developed by Fernando J. Corbat\'o et al. in 1962, and this work, along with other work on Multics, led the ACM to award Corbat\'o the Turing Award.},
  annotation = {Page Version ID: 980335026},
  copyright = {Creative Commons Attribution-ShareAlike License},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\EZRHDH7Z\\index.html},
  journal = {Wikipedia},
  language = {en}
}

@article{MultilevelQueue2018,
  title = {Multilevel Queue},
  year = {2018},
  month = nov,
  abstract = {Multi-level queueing, used at least since the late 1950s/early 1960s, is a queue with a predefined number of levels. Unlike the multilevel feedback queue, items get assigned to a particular level at insert (using some predefined algorithm), and thus cannot be moved to another level. Items get removed from the queue by removing all items from a level, and then moving to the next. If an item is added to a level above, the "fetching" restarts from there. Each level of the queue is free to use its own scheduling, thus adding greater flexibility than merely having multiple levels in a queue.},
  annotation = {Page Version ID: 868984935},
  copyright = {Creative Commons Attribution-ShareAlike License},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\FLUWRE5P\\index.html},
  journal = {Wikipedia},
  language = {en}
}

@inproceedings{negiApplyingMachineLearning2005,
  title = {Applying {{Machine Learning Techniques}} to {{Improve Linux Process Scheduling}}},
  author = {Negi, Atul and Pusukuri, Kishore Kumar},
  year = {2005},
  month = dec,
  volume = {2007},
  pages = {1--6},
  doi = {10.1109/TENCON.2005.300837},
  abstract = {In this work we use Machine Learning (ML) techniques to learn the CPU time-slice utilization behavior of known programs in a Linux system. Learning is done by an analysis of certain static and dynamic attributes of the processes while they are being run. Our objective was to discover the most important static and dynamic attributes of the processes that can help best in prediction of CPU burst times which minimize the process TaT (Turn-around-Time). In our experimentation we modify the Linux Kernel scheduler (version 2.4.20-8) to allow scheduling with customized time slices. The "Waikato Environment for Knowledge Analysis" (Weka), an open source machine-learning tool is used to find the most suitable ML method to characterize our programs. We experimentally find that the C'4.5 Decision Tree algorithm most effectively solved the problem. We find that predictive scheduling could reduce TaT in the range of 1.4\% to 5.8\%. This was due to a reduction in the number of context switches needed to complete the process execution. We find our result interesting in the context that generally operating systems presently never make use of a program's previous execution history in their scheduling behavior.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\E5CEVNQR\\Negi and Pusukuri - 2005 - Applying Machine Learning Techniques to Improve Li.pdf}
}

@misc{neiderWhatDifferenceQuantum2008,
  title = {What's the Difference between {{Quantum}} and {{Timeslice}} ?},
  author = {Neider, Raphael},
  year = {Thu Sep 18 11:04:12 CEST 2008}
}

@article{ojhaLEARNINGSCHEDULERPARAMETERS,
  title = {{{LEARNING SCHEDULER PARAMETERS FOR ADAPTIVE PREEMPTION}}},
  author = {Ojha, Prakhar and Thota, Siddhartha R},
  pages = {14},
  abstract = {An operating system scheduler is expected to not allow processor stay idle if there is any process ready or waiting for its execution. This problem gains more importance as the numbers of processes always outnumber the processors by large margins. It is in this regard that schedulers are provided with the ability to preempt a running process, by following any scheduling algorithm, and give us an illusion of simultaneous running of several processes. A process which is allowed to utilize CPU resources for a fixed quantum of time (termed as timeslice for preemption) and is then preempted for another waiting process. Each of these 'process preemption' leads to considerable overhead of CPU cycles which are valuable resource for runtime execution. In this work we try to utilize the historical performances of a scheduler and predict the nature of current running process, thereby trying to reduce the number of preemptions. We propose a machine-learning module to predict a better performing timeslice which is calculated based on static knowledge base and adaptive reinforcement learning based suggestive module. Results for an "adaptive timeslice parameter" for preemption show good saving on CPU cycles and efficient throughput time.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\WXD2WMYD\\Ojha and Thota - LEARNING SCHEDULER PARAMETERS FOR ADAPTIVE PREEMPT.pdf},
  journal = {Computer Science},
  language = {en}
}

@misc{Proc,
  title = {/Proc},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\WDGILARW\\proc.html},
  howpublished = {https://tldp.org/LDP/Linux-Filesystem-Hierarchy/html/proc.html}
}

@misc{Project2bXv6,
  title = {Project 2b: Xv6 {{Scheduler}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\KHHRLJIX\\p2b.html},
  howpublished = {http://pages.cs.wisc.edu/\textasciitilde gerald/cs537/Fall17/projects/p2b.html}
}

@article{rinkuReinforcementLearningBased2020,
  title = {Reinforcement Learning Based Multi Core Scheduling ({{RLBMCS}}) for Real Time Systems},
  author = {Rinku, Dhruva R. and AshaRani, M.},
  year = {2020},
  month = apr,
  volume = {10},
  pages = {1805},
  issn = {2088-8708, 2088-8708},
  doi = {10.11591/ijece.v10i2.pp1805-1813},
  abstract = {Embedded systems with multi core processors are increasingly popular because of the diversity of applications that can be run on it. In this work, a reinforcement learning based scheduling method is proposed to handle the real time tasks in multi core systems with effective CPU usage and lower response time. The priority of the tasks is varied dynamically to ensure fairness with reinforcement learning based priority assignment and Multi Core MultiLevel Feedback queue (MCMLFQ) to manage the task execution in multi core system.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\MSQFZKDW\\Rinku and AshaRani - 2020 - Reinforcement learning based multi core scheduling.pdf},
  journal = {International Journal of Electrical and Computer Engineering (IJECE)},
  language = {en},
  number = {2}
}

@misc{sandlerPart08Processes,
  title = {Part 08 - {{Processes}}},
  author = {Sandler, Jake},
  abstract = {One of the most important responsibilities of the kernel is to provide an interface to start processes, and to switch between processes seemlessly. We need to be able to stop a process from executing, save its state, start another process, and restore the first process later without it ever realizing it was not executing.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\UUKHXFIQ\\process.html},
  howpublished = {http://jsandler18.github.io/tutorial/process.html},
  journal = {Building an Operating System for the Raspberry Pi},
  language = {en}
}

@incollection{satyanarayanaImprovedProcessScheduling2018,
  title = {Improved {{Process Scheduling}} in {{Real}}-{{Time Operating Systems Using Support Vector Machines}}},
  booktitle = {Proceedings of 2nd {{International Conference}} on {{Micro}}-{{Electronics}}, {{Electromagnetics}} and {{Telecommunications}}},
  author = {Satyanarayana, S. and Sravan Kumar, P. and Sridevi, G.},
  editor = {Satapathy, Suresh Chandra and Bhateja, Vikrant and Chowdary, P. Satish Rama and Chakravarthy, V.V.S.S. Sameer and Anguera, Jaume},
  year = {2018},
  volume = {434},
  pages = {603--611},
  publisher = {{Springer Singapore}},
  address = {{Singapore}},
  doi = {10.1007/978-981-10-4280-5_63},
  abstract = {In the field operating systems, most advanced scheduling method is Multilevel Feedback Scheduling. There are multiple queues with different level priorities (high to low). Selection of each process from a queue is based on the priority of the queue. Support Vector Machine (SVM) method is learning linear predictions in high-dimensional feature spaces. SVM approach can handle the sample complexity challenges by searching large margin separators. In this paper, we are proposing an innovative machine learning Support Vector Machines to predict priorities of multiple queues based on the knowledge of past processes in real-time Operating Systems. This approach can train each queue with linear predictions. So that real-time operating systems like Embedded Systems/Firmware can handle nonhomogenous tasks also. The problem of predicting large volume of processes can be solved with high performance. This algorithm is tested with onelakh processes and these processes are scheduled in 1 min 5.377 s.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\FEEA9GEY\\Satyanarayana et al. - 2018 - Improved Process Scheduling in Real-Time Operating.pdf},
  isbn = {978-981-10-4279-9 978-981-10-4280-5},
  language = {en}
}

@misc{Scheduler,
  title = {4.1: {{Scheduler}}},
  shorttitle = {4.1},
  abstract = {Learning operating system development using Linux kernel and Raspberry Pi},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\RS9KV84H\\rpi-os.html},
  howpublished = {https://s-matyukevich.github.io/raspberry-pi-os/docs/lesson04/rpi-os.html},
  journal = {raspberry-pi-os},
  language = {en-US}
}

@article{SchedulingComputing2020,
  title = {Scheduling (Computing)},
  year = {2020},
  month = oct,
  abstract = {In computing, scheduling is the method by which work is assigned to resources that complete the work.  The work may be virtual computation elements such as threads, processes or data flows, which are in turn scheduled onto hardware resources such as processors, network links or expansion cards. A scheduler is what carries out the scheduling activity.  Schedulers are often implemented so they keep all computer resources busy (as in load balancing), allow multiple users to share system resources effectively, or to achieve a target quality of service.  Scheduling is fundamental to computation itself, and an intrinsic part of the execution model of a computer system; the concept of scheduling makes it possible to have computer multitasking with a single central processing unit (CPU).},
  annotation = {Page Version ID: 984502873},
  copyright = {Creative Commons Attribution-ShareAlike License},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\F4L2U8K7\\index.html},
  journal = {Wikipedia},
  language = {en}
}

@misc{seltzerUnderstandingCgroups2018,
  title = {Understanding Cgroups},
  author = {Seltzer, Grant},
  year = {2018},
  month = nov,
  abstract = {Control groups (or cgroups) are a feature of the Linux kernel by which groups of processes can be monitored and have their resources limited. For example, if you don't want a google chrome process (or it's many child processes) to exceed a gigabyte of RAM or 30\% total CPU usage, cgroups would let you do that. They are an extremely powerful tool by which you can guarentee limits on performance, but understanding how they work and how to use them can be a little daunting.},
  journal = {grant.pizza}
}

@misc{SettingLinuxCgroups,
  title = {Setting {{Up Linux}} Cgroups - {{Control Groups}}},
  abstract = {Helpful Tips and Tricks for Linux Systems Engineers and Administrators.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\XLTQ7BMU\\setting-up-linux-cgroups-control-groups.html}
}

@misc{SystemdLinuxManual,
  title = {Systemd(1) - {{Linux}} Manual Page},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\8P87MRTP\\systemd.1.html},
  howpublished = {https://man7.org/linux/man-pages/man1/systemd.1.html}
}

@misc{ToolboxRenicePlatform,
  title = {Toolbox/Renice.c - Platform/System/Core - {{Git}} at {{Google}}},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\8SCBE8GI\\renice.html},
  howpublished = {https://android.googlesource.com/platform/system/core/+/kitkat-release/toolbox/renice.c}
}

@misc{UnderstandingLinuxContainer,
  title = {Understanding {{Linux Container Scheduling}}},
  abstract = {It is important to understand how containers are implemented using Linux control groups (cgroups) and namespaces. Understanding the features and limitations has helped us dramatically improve the performance of our Java services especially under stressful scenarios.},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\ZFHQ7WFU\\understanding-linux-container-scheduling.html},
  howpublished = {https://engineering.squarespace.com/blog/2017/understanding-linux-container-scheduling},
  journal = {Squarespace / Engineering},
  language = {en-US}
}

@misc{WhatRelationshipCpu,
  title = {What Is the Relationship between Cpu.Shares and Cpu.Cfs\_quota\_us in Context of Cgroup?},
  file = {C\:\\Users\\jonat\\Zotero\\storage\\S59P9IS8\\what-is-the-relationship-between-cpu-shares-and-cpu-cfs-quota-us-in-context-of-c.html},
  howpublished = {https://stackoverflow.com/questions/55901070/what-is-the-relationship-between-cpu-shares-and-cpu-cfs-quota-us-in-context-of-c},
  journal = {Stack Overflow}
}

@misc{zotero-540,
  file = {C\:\\Users\\jonat\\Zotero\\storage\\B7BLJZR2\\understanding-cgroups.html},
  howpublished = {https://www.grant.pizza/blog/understanding-cgroups/}
}


