
@article{beheraEnergyefficientTimetriggeredScheduling2020,
  title = {An Energy-Efficient Time-Triggered Scheduling Algorithm for Mixed-Criticality Systems},
  author = {Behera, Lalatendu and Bhaduri, Purandar},
  year = {2020},
  month = jun,
  volume = {24},
  pages = {79--109},
  issn = {1572-8080},
  doi = {10.1007/s10617-019-09232-3},
  abstract = {Real-time safety-critical systems are getting more complicated due to the introduction of mixed-criticality systems. The increasing use of mixed-criticality systems has motivated the real-time systems research community to investigate various non-functional aspects of these systems. Energy consumption minimization is one such aspect which is just beginning to be explored. In this paper, we propose a time-triggered dynamic voltage and frequency scaling (DVFS) algorithm for uniprocessor mixed-criticality systems. We show that our algorithm outperforms the predominant existing algorithm which uses DVFS for mixed-criticality systems with respect to minimization of energy consumption. In addition, ours is the first energy-efficient time-triggered algorithm for mixed-criticality systems. We prove an optimality result for the proposed algorithm with respect to energy consumption. Then we extend our algorithm for tasks with dependency constraints.},
  journal = {Design Automation for Embedded Systems},
  language = {en},
  number = {2}
}

@article{BrainFuckScheduler2020,
  title = {Brain {{Fuck Scheduler}}},
  year = {2020},
  month = oct,
  abstract = {The Brain Fuck Scheduler (BFS) is a process scheduler designed for the Linux kernel in August 2009 as an alternative to the Completely Fair Scheduler (CFS) and the O(1) scheduler. BFS was created by veteran kernel programmer Con Kolivas.The objective of BFS, compared to other schedulers, is to provide a scheduler with a simpler algorithm, that does not require adjustment of heuristics or tuning parameters to tailor performance to a specific type of computational workload. Kolivas asserted that these tunable parameters were difficult for the average user to understand, especially in terms of interactions of multiple parameters with each other, and claimed that the use of such tuning parameters could often result in improved performance in a specific targeted type of computation, at the cost of worse performance in the general case. BFS has been reported to improve responsiveness on Linux desktop computers with fewer than 16 cores.Shortly following its introduction, the new scheduler made headlines within the Linux community, appearing on Slashdot, with reviews in Linux Magazine and Linux Pro Magazine. Although there have been varied reviews of improved performance and responsiveness, Con Kolivas did not intend for BFS to be integrated into the mainline kernel.},
  annotation = {Page Version ID: 982869148},
  copyright = {Creative Commons Attribution-ShareAlike License},
  file = {/home/nahtonaj/Zotero/storage/DXPX43QK/index.html},
  journal = {Wikipedia},
  language = {en}
}

@misc{ConfiguringKernelRaspberry,
  title = {Configuring the Kernel - {{Raspberry Pi Documentation}}},
  howpublished = {https://www.raspberrypi.org/documentation/linux/kernel/configuring.md}
}

@misc{CPUFrequencyScaling,
  title = {{{CPU}} Frequency Scaling - {{ArchWiki}}},
  file = {/home/nahtonaj/Zotero/storage/XI9RXE4E/CPU_frequency_scaling.html},
  howpublished = {https://wiki.archlinux.org/index.php/CPU\_frequency\_scaling}
}

@misc{CpuschedmultiPdf,
  title = {Cpu-Sched-Multi.Pdf},
  file = {/home/nahtonaj/Zotero/storage/FQW9X6E3/cpu-sched-multi.pdf},
  howpublished = {http://pages.cs.wisc.edu/\textasciitilde remzi/OSTEP/cpu-sched-multi.pdf}
}

@misc{DifferenceMultilevelQueue2020,
  title = {Difference between {{Multilevel Queue}} ({{MLQ}}) and {{Multi Level Feedback Queue}} ({{MLFQ}}) {{CPU}} Scheduling Algorithms},
  year = {2020},
  month = jul,
  abstract = {A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.},
  chapter = {Operating Systems},
  file = {/home/nahtonaj/Zotero/storage/PUQTV2HN/difference-between-multilevel-queue-mlq-and-multi-level-feedback-queue-mlfq-cpu-scheduling-algo.html},
  howpublished = {https://www.geeksforgeeks.org/difference-between-multilevel-queue-mlq-and-multi-level-feedback-queue-mlfq-cpu-scheduling-algorithms/},
  journal = {GeeksforGeeks},
  language = {en-US},
  type = {{{GeeksforGeeks}}}
}

@misc{KernelBuildingRaspberrya,
  title = {Kernel Building - {{Raspberry Pi Documentation}}},
  file = {/home/nahtonaj/Zotero/storage/L3W2LPGQ/building.html},
  howpublished = {https://www.raspberrypi.org/documentation/linux/kernel/building.md}
}

@misc{KernelBuildYourOwnKernelUbuntu,
  title = {Kernel/{{BuildYourOwnKernel}} - {{Ubuntu Wiki}}},
  howpublished = {https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel}
}

@misc{KernelOrg,
  title = {Kernel.Org},
  file = {/home/nahtonaj/Zotero/storage/HGII4WX4/kconfig.html},
  howpublished = {https://www.kernel.org/doc/Documentation/kbuild/kconfig.txt}
}

@misc{LIBSVMLibrarySupport,
  title = {{{LIBSVM}} -- {{A Library}} for {{Support Vector Machines}}},
  file = {/home/nahtonaj/Zotero/storage/UJ3432KE/libsvm.html},
  howpublished = {https://www.csie.ntu.edu.tw/\textasciitilde cjlin/libsvm/}
}

@misc{misitiJosephmisitiAwesomemachinelearning2020,
  title = {Josephmisiti/Awesome-Machine-Learning},
  author = {Misiti, Joseph},
  year = {2020},
  month = oct,
  abstract = {A curated list of awesome Machine Learning frameworks, libraries and software.},
  copyright = {View license         ,                 View license}
}

@article{MultilevelQueue2018,
  title = {Multilevel Queue},
  year = {2018},
  month = nov,
  abstract = {Multi-level queueing, used at least since the late 1950s/early 1960s, is a queue with a predefined number of levels. Unlike the multilevel feedback queue, items get assigned to a particular level at insert (using some predefined algorithm), and thus cannot be moved to another level. Items get removed from the queue by removing all items from a level, and then moving to the next. If an item is added to a level above, the "fetching" restarts from there. Each level of the queue is free to use its own scheduling, thus adding greater flexibility than merely having multiple levels in a queue.},
  annotation = {Page Version ID: 868984935},
  copyright = {Creative Commons Attribution-ShareAlike License},
  file = {/home/nahtonaj/Zotero/storage/FLUWRE5P/index.html},
  journal = {Wikipedia},
  language = {en}
}

@article{rinkuReinforcementLearningBased2020,
  title = {Reinforcement Learning Based Multi Core Scheduling ({{RLBMCS}}) for Real Time Systems},
  author = {Rinku, Dhruva R. and AshaRani, M.},
  year = {2020},
  month = apr,
  volume = {10},
  pages = {1805},
  issn = {2088-8708, 2088-8708},
  doi = {10.11591/ijece.v10i2.pp1805-1813},
  abstract = {Embedded systems with multi core processors are increasingly popular because of the diversity of applications that can be run on it. In this work, a reinforcement learning based scheduling method is proposed to handle the real time tasks in multi core systems with effective CPU usage and lower response time. The priority of the tasks is varied dynamically to ensure fairness with reinforcement learning based priority assignment and Multi Core MultiLevel Feedback queue (MCMLFQ) to manage the task execution in multi core system.},
  file = {/home/nahtonaj/Zotero/storage/MSQFZKDW/Rinku and AshaRani - 2020 - Reinforcement learning based multi core scheduling.pdf},
  journal = {International Journal of Electrical and Computer Engineering (IJECE)},
  language = {en},
  number = {2}
}

@misc{sandlerPart08Processes,
  title = {Part 08 - {{Processes}}},
  author = {Sandler, Jake},
  abstract = {One of the most important responsibilities of the kernel is to provide an interface to start processes, and to switch between processes seemlessly. We need to be able to stop a process from executing, save its state, start another process, and restore the first process later without it ever realizing it was not executing.},
  file = {/home/nahtonaj/Zotero/storage/UUKHXFIQ/process.html},
  howpublished = {http://jsandler18.github.io/tutorial/process.html},
  journal = {Building an Operating System for the Raspberry Pi},
  language = {en}
}

@incollection{satyanarayanaImprovedProcessScheduling2018,
  title = {Improved {{Process Scheduling}} in {{Real}}-{{Time Operating Systems Using Support Vector Machines}}},
  booktitle = {Proceedings of 2nd {{International Conference}} on {{Micro}}-{{Electronics}}, {{Electromagnetics}} and {{Telecommunications}}},
  author = {Satyanarayana, S. and Sravan Kumar, P. and Sridevi, G.},
  editor = {Satapathy, Suresh Chandra and Bhateja, Vikrant and Chowdary, P. Satish Rama and Chakravarthy, V.V.S.S. Sameer and Anguera, Jaume},
  year = {2018},
  volume = {434},
  pages = {603--611},
  publisher = {{Springer Singapore}},
  address = {{Singapore}},
  doi = {10.1007/978-981-10-4280-5_63},
  abstract = {In the field operating systems, most advanced scheduling method is Multilevel Feedback Scheduling. There are multiple queues with different level priorities (high to low). Selection of each process from a queue is based on the priority of the queue. Support Vector Machine (SVM) method is learning linear predictions in high-dimensional feature spaces. SVM approach can handle the sample complexity challenges by searching large margin separators. In this paper, we are proposing an innovative machine learning Support Vector Machines to predict priorities of multiple queues based on the knowledge of past processes in real-time Operating Systems. This approach can train each queue with linear predictions. So that real-time operating systems like Embedded Systems/Firmware can handle nonhomogenous tasks also. The problem of predicting large volume of processes can be solved with high performance. This algorithm is tested with onelakh processes and these processes are scheduled in 1 min 5.377 s.},
  file = {/home/nahtonaj/Zotero/storage/FEEA9GEY/Satyanarayana et al. - 2018 - Improved Process Scheduling in Real-Time Operating.pdf},
  isbn = {978-981-10-4279-9 978-981-10-4280-5},
  language = {en}
}

@misc{Scheduler,
  title = {4.1: {{Scheduler}}},
  shorttitle = {4.1},
  abstract = {Learning operating system development using Linux kernel and Raspberry Pi},
  file = {/home/nahtonaj/Zotero/storage/RS9KV84H/rpi-os.html},
  howpublished = {https://s-matyukevich.github.io/raspberry-pi-os/docs/lesson04/rpi-os.html},
  journal = {raspberry-pi-os},
  language = {en-US}
}

@article{SchedulingComputing2020,
  title = {Scheduling (Computing)},
  year = {2020},
  month = oct,
  abstract = {In computing, scheduling is the method by which work is assigned to resources that complete the work.  The work may be virtual computation elements such as threads, processes or data flows, which are in turn scheduled onto hardware resources such as processors, network links or expansion cards. A scheduler is what carries out the scheduling activity.  Schedulers are often implemented so they keep all computer resources busy (as in load balancing), allow multiple users to share system resources effectively, or to achieve a target quality of service.  Scheduling is fundamental to computation itself, and an intrinsic part of the execution model of a computer system; the concept of scheduling makes it possible to have computer multitasking with a single central processing unit (CPU).},
  annotation = {Page Version ID: 984502873},
  copyright = {Creative Commons Attribution-ShareAlike License},
  file = {/home/nahtonaj/Zotero/storage/F4L2U8K7/index.html},
  journal = {Wikipedia},
  language = {en}
}


