% !TeX root = ./weekly-report-10-26-20.tex
\documentclass[12pt]{article}
% \usepackage{fullpage}
\usepackage{epic}
\usepackage{eepic}
\usepackage{paralist}
\usepackage{graphicx}
\usepackage{algorithm,algorithmic}
\usepackage{tikz}
\usepackage{xcolor,colortbl}
\usepackage{wrapfig}
\usepackage{float}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is FULLPAGE.STY by H.Partl, Version 2 as of 15 Dec 1988.
% Document Style Option to fill the paper just like Plain TeX.

\typeout{Style Option FULLPAGE Version 2 as of 15 Dec 1988}

\topmargin 0pt
\advance \topmargin by -\headheight
\advance \topmargin by -\headsep

\textheight 8.9in

\oddsidemargin 0pt
\evensidemargin \oddsidemargin
\marginparwidth 0.5in

\textwidth 6.5in
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty}
\setlength{\oddsidemargin}{0in}
\setlength{\topmargin}{-0.8in}
\setlength{\textwidth}{6.8in}
\setlength{\textheight}{9.5in}


\def\ind{\hspace*{0.3in}}
\def\gap{0.1in}
\def\bigap{0.25in}
\newcommand{\Xomit}[1]{}


\begin{document}

\setlength{\parindent}{0in}
\addtolength{\parskip}{0.1cm}
\setlength{\fboxrule}{.5mm}\setlength{\fboxsep}{1.2mm}
\newlength{\boxlength}\setlength{\boxlength}{\textwidth}
\addtolength{\boxlength}{-4mm}
\begin{center}\framebox{\parbox{\boxlength}{{\bf
MENG PROJECT, FA20\hfill Linux Kernel Modifications}\\
% TODO: fill in your own name, netID, and collaborators
Name: Jonathan Gao\hfill 
NetID: jg992
}}
\end{center}
\vspace{2mm}

\section*{Progress this week}
\ind I went through the Lab 4 guide for ECE 5725, and have cross-compiled and patched the kernel for Raspberry Pi OS 5.4.72. This was relatively straightforward and I didn't run into much trouble doing so. 

I also read through several papers discussing learning algorithms in multi-level feedback queue. The first one, which uses support vector machines to predict priorities~\cite{satyanarayanaImprovedProcessScheduling2018}, was very unsubstantial and had almost no analysis or validation of results. Rather it seems like it was a roughly put together paper for school. I did have some takeaways, where an prediction algorithm can prevent a scheduler from sorting processes according to their burst times. The other paper by Rinku and AshaRani~\cite{rinkuReinforcementLearningBased2020} was much more insightful. They used an objective function for promoting/demoting between several types of queues. The multi-objective function uses weights that are learned over time, meaning that the scheduler will learn to optimize for processes it has seen. This is similar to the genetic algorithm idea I had, and it also doesn't require any learning data! This might be the way to go.

I also found some resources teaching you how to write your own OS, which includes how to write a scheduler that could be helpful~\cite{sandlerPart08Processes}~\cite{Scheduler}

\section*{Plan for coming week}
\ind I'm still reading through several other papers, but I want to start working with the kernel next week. Next week may end up being a busy week, so I will see what I can get through. 

Hoping to dig into the kernel code itself, and seeing if I can determine how the code works.
\section*{Problems}
No problems so far.
\section*{Long term plan: still OK?}
Hopefully so! 

\bibliographystyle{ieeetr}
\bibliography{references}




\end{document}

